{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to <code>isotropic</code>","text":"<p><code>isotropic</code> is a python package for isotropic error analysis in quantum computing. The library provides a comprehensive set of tools to model and generate isotropic errors to test their effect on various quantum algorithms.</p> <p>Broadly this involves the following steps:</p> <ol> <li>Construct an orthonormal basis of $\\Pi$ with center at $\\Phi$.</li> <li>Generate a vector $e_2$ in $S_{d\u22121}$ with uniform distribution.</li> <li>Generate an angle $\\theta_0$ in $[0,\\pi]$ with density function $f(\\theta_0)$.</li> <li>Generate the final perturbed state $\\Psi$ as a rotation of $e_1 = \\Phi$ by angle $\\theta_0$ in the subspace spanned by the orthonormal basis $[e_1,e_2]$ using the expression $$\\Psi = \\Phi \\cos(\\theta_0) + e_2 \\sin(\\theta_0)$$</li> </ol>"},{"location":"#installation","title":"Installation","text":"<p>You can install <code>isotropic</code> from <code>pip</code> with:</p> <pre><code>pip install isotropic\n</code></pre> <p>If you want to test the effect of isotropic errors with one of the included quantum algorithm implementations, consider installing with the <code>all</code> option as such:</p> <pre><code>pip install isotropic\\[all\\]\n</code></pre>"},{"location":"#api-reference","title":"API Reference","text":"<p>This library provides modules to perform each of the steps outlined above. See below for the API reference:</p> <ul> <li>Algorithms</li> <li>Coefficients of e2</li> <li>Orthonormal basis</li> <li>Theta Zero</li> <li>Utilities</li> </ul>"},{"location":"algos/","title":"<code>algos</code>","text":"<p>This module contains Qiskit implementations of example algorithms to analyse the effects of isotropic errors.</p>"},{"location":"algos/#isotropic.algos","title":"<code>isotropic.algos</code>","text":""},{"location":"algos/#isotropic.algos.grover","title":"<code>grover</code>","text":""},{"location":"algos/#isotropic.algos.grover.get_grover_answer","title":"<code>get_grover_answer(result)</code>","text":"<p>Extract the measurement counts from the result of a Grover circuit execution.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>PrimitiveResult</code> <p>The result object returned by executing the Grover circuit.</p> required <p>Returns:</p> Type Description <code>tuple[dict, str]</code> <p>A tuple containing the counts dictionary and the most probable search item.</p> Source code in <code>src/isotropic/algos/grover.py</code> <pre><code>def get_grover_answer(result: PrimitiveResult) -&gt; tuple[dict, str]:\n    \"\"\"\n    Extract the measurement counts from the result of a Grover circuit execution.\n\n    Parameters\n    ----------\n    result : PrimitiveResult\n        The result object returned by executing the Grover circuit.\n\n    Returns\n    -------\n    tuple[dict, str]\n        A tuple containing the counts dictionary and the most probable search item.\n    \"\"\"\n    if not isinstance(result, PrimitiveResult):\n        raise TypeError(\"The result must be an instance of PrimitiveResult.\")\n\n    counts = result[0].data.c0.get_counts()\n    grover_answer = max(counts, key=counts.get)\n\n    return counts, grover_answer\n</code></pre>"},{"location":"algos/#isotropic.algos.grover.get_grover_circuit","title":"<code>get_grover_circuit(num_qubits, U_w, iterations)</code>","text":"<p>Create a Grover circuit with the given number of qubits, oracle, and iterations.</p> <p>Parameters:</p> Name Type Description Default <code>num_qubits</code> <code>int</code> <p>The number of qubits used to encode the states.</p> required <code>U_w</code> <code>Operator</code> <p>The oracle that marks the solution states.</p> required <code>iterations</code> <code>int</code> <p>The number of Grover iterations to perform.</p> required <p>Returns:</p> Type Description <code>QuantumCircuit</code> <p>The constructed Grover quantum circuit.</p> Source code in <code>src/isotropic/algos/grover.py</code> <pre><code>def get_grover_circuit(\n    num_qubits: int, U_w: Operator, iterations: int\n) -&gt; QuantumCircuit:\n    \"\"\"\n    Create a Grover circuit with the given number of qubits, oracle, and iterations.\n\n    Parameters\n    ----------\n    num_qubits : int\n        The number of qubits used to encode the states.\n    U_w : Operator\n        The oracle that marks the solution states.\n    iterations : int\n        The number of Grover iterations to perform.\n\n    Returns\n    -------\n    QuantumCircuit\n        The constructed Grover quantum circuit.\n    \"\"\"\n\n    if U_w.num_qubits != num_qubits:\n        raise ValueError(\n            \"Oracle U_w must have the same number of qubits as num_qubits.\"\n        )\n\n    qr = QuantumRegister(num_qubits)\n    cr = ClassicalRegister(num_qubits)\n    qcirc = QuantumCircuit(qr, cr)\n\n    # Initializing the circuit\n    for i in range(num_qubits):\n        qcirc.h(i)\n\n    for i in range(iterations):\n        qcirc.barrier()\n\n        # Oracle to introduce negative phase (circuit of above matrix)\n        qcirc.append(U_w, qr)\n\n        qcirc.barrier()\n\n        # Diffusion operator\n        for qubit in range(num_qubits):\n            qcirc.h(qubit)\n        for qubit in range(num_qubits):\n            qcirc.x(qubit)\n        qcirc.h(num_qubits - 1)\n        qcirc.mcx(list(range(num_qubits - 1)), num_qubits - 1)\n        qcirc.h(num_qubits - 1)\n        for qubit in range(num_qubits):\n            qcirc.x(qubit)\n        for qubit in range(num_qubits):\n            qcirc.h(qubit)\n\n    return qcirc\n</code></pre>"},{"location":"algos/#isotropic.algos.grover.optimal_num_iterations","title":"<code>optimal_num_iterations(num_solutions, num_qubits)</code>","text":"<p>Return the optimal number of iterations, if the number of solutions is known.</p> <p>Parameters:</p> Name Type Description Default <code>num_solutions</code> <code>int</code> <p>The number of solutions.</p> required <code>num_qubits</code> <code>int</code> <p>The number of qubits used to encode the states.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The optimal number of iterations for Grover's algorithm to succeed.</p> Source code in <code>src/isotropic/algos/grover.py</code> <pre><code>def optimal_num_iterations(num_solutions: int, num_qubits: int) -&gt; int:\n    \"\"\"\n    Return the optimal number of iterations, if the number of solutions is known.\n\n    Parameters\n    ----------\n    num_solutions : int\n        The number of solutions.\n    num_qubits : int\n        The number of qubits used to encode the states.\n\n    Returns\n    -------\n    int\n        The optimal number of iterations for Grover's algorithm to succeed.\n    \"\"\"\n    amplitude = jnp.sqrt(num_solutions / 2**num_qubits)\n    return round(jnp.arccos(amplitude) / (2 * jnp.arcsin(amplitude)))\n</code></pre>"},{"location":"e2/","title":"<code>e2</code>","text":"<p>This module contains functions to calculate the coefficients which are multipled with the orthonormal basis to make up the $e_2$ vector.</p>"},{"location":"e2/#isotropic.e2","title":"<code>isotropic.e2</code>","text":"<p>This module contains functions for generating the vector $e_2$.</p>"},{"location":"e2/#isotropic.e2.F_j","title":"<code>F_j(theta_j, j, d)</code>","text":"<p>Calculate the function $F_j$ for the given angle $\\theta_j$ and index $j$ in dimension $d$.</p> <p>Parameters:</p> Name Type Description Default <code>theta_j</code> <code>float</code> <p>The angle at which to evaluate the function.</p> required <code>j</code> <code>int</code> <p>The index corresponding to the angle.</p> required <code>d</code> <code>int</code> <p>The dimension of the space.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>The value of the function $F_j$ evaluated at $\\theta_j$.</p> Source code in <code>src/isotropic/e2.py</code> <pre><code>def F_j(theta_j: float, j: int, d: int) -&gt; Array:\n    \"\"\"\n    Calculate the function $F_j$ for the given angle $\\\\theta_j$ and index $j$ in dimension $d$.\n\n    Parameters\n    ----------\n    theta_j : float\n        The angle at which to evaluate the function.\n    j : int\n        The index corresponding to the angle.\n    d : int\n        The dimension of the space.\n\n    Returns\n    -------\n    Array\n        The value of the function $F_j$ evaluated at $\\\\theta_j$.\n    \"\"\"\n    dj = d - j\n    numoverden = double_factorial_ratio_scipy(dj - 2, dj - 1)\n\n    def F_odd(_):\n        C_j = (1 / 2) * double_factorial_ratio_scipy(dj - 1, dj - 2)\n        prefactor = C_j * numoverden\n        k_max = (dj - 2) // 2  # upper bound for k in range\n        k_vals = jnp.arange(0, k_max + 1)\n\n        def product_term(k):\n            num_factors = jnp.arange(dj - 2, 2 * k + 1, -2)\n            den_factors = jnp.arange(dj - 1, 2 * k, -2)\n            num_prod = jnp.prod(num_factors) if num_factors.size &gt; 0 else 1.0\n            den_prod = jnp.prod(den_factors) if den_factors.size &gt; 0 else 1.0\n            return (num_prod / den_prod) * jnp.sin(theta_j) ** (2 * k)\n\n        # TODO: Use vectorization for better performance\n        # sum_terms = jnp.sum(jnp.vectorize(product_term)(k_vals))\n        sum_terms = 0.0\n        for k in k_vals:\n            sum_terms += product_term(k)\n        return prefactor - C_j * jnp.cos(theta_j) * sum_terms\n\n    def F_even(_):\n        C_j = (1 / jnp.pi) * double_factorial_ratio_scipy(dj - 1, dj - 2)\n        prefactor = C_j * numoverden * theta_j\n        k_max = (dj - 1) // 2\n        k_vals = jnp.arange(1, k_max + 1)\n\n        def product_term(k):\n            num_factors = jnp.arange(dj - 2, 2 * k, -2)\n            den_factors = jnp.arange(dj - 1, 2 * k - 1, -2)\n            num_prod = jnp.prod(num_factors) if num_factors.size &gt; 0 else 1.0\n            den_prod = jnp.prod(den_factors) if den_factors.size &gt; 0 else 1.0\n            return (num_prod / den_prod) * jnp.sin(theta_j) ** (2 * k - 1)\n\n        # TODO: Use vectorization for better performance\n        # sum_terms = jnp.sum(jnp.vectorize(product_term)(k_vals))\n        sum_terms = 0.0\n        for k in k_vals:\n            sum_terms += product_term(k)\n        return prefactor - C_j * jnp.cos(theta_j) * sum_terms\n\n    # TODO: Use a conditional to choose between F_odd and F_even based on j\n    # return lax.cond(j % 2 == 1, F_odd, F_even, operand=None)\n    if j % 2 == 1:\n        return F_odd(None)\n    else:\n        return F_even(None)\n</code></pre>"},{"location":"e2/#isotropic.e2.get_e2_coeffs","title":"<code>get_e2_coeffs(d, F_j, key=random.PRNGKey(0))</code>","text":"<p>Generate the coefficients of the vector $e_2$.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>int</code> <p>Dimension of the space.</p> required <code>F_j</code> <code>Callable</code> <p>Function to compute $F_j$ for the given angle, dimension and index.</p> required <code>key</code> <code>ArrayLike</code> <p>Random key for reproducibility, by default random.PRNGKey(0).</p> <code>PRNGKey(0)</code> <p>Returns:</p> Type Description <code>Tuple[Array, Array]</code> <p>A tuple containing:</p> <ul> <li>theta: Array of angles used to construct $e_2$.</li> <li>e2: Array representing the coefficients of the vector $e_2$.</li> </ul> Source code in <code>src/isotropic/e2.py</code> <pre><code>def get_e2_coeffs(\n    d: int, F_j: Callable, key: ArrayLike = random.PRNGKey(0)\n) -&gt; Tuple[Array, Array]:\n    \"\"\"\n    Generate the coefficients of the vector $e_2$.\n\n    Parameters\n    ----------\n    d : int\n        Dimension of the space.\n    F_j : Callable\n        Function to compute $F_j$ for the given angle, dimension and index.\n    key : ArrayLike, optional\n        Random key for reproducibility, by default random.PRNGKey(0).\n\n    Returns\n    -------\n    Tuple[Array, Array]\n        A tuple containing:\n\n        - theta: Array of angles used to construct $e_2$.\n        - e2: Array representing the coefficients of the vector $e_2$.\n    \"\"\"\n    theta: Array = jnp.zeros(d - 1)\n\n    # Generate theta_{d-1} from a uniform distribution in [0, 2*pi]\n    theta = theta.at[-1].set(random.uniform(key, shape=(), minval=0, maxval=2 * jnp.pi))\n\n    # Generate theta_j for j = 1, ..., d-2 using bisection method\n    # TODO: vectorize this loop\n    for j in range(0, d - 2, 1):\n        # JAX PRNG is stateless, so we need to split the key\n        key, subkey = random.split(key)\n        x = random.uniform(key, shape=(), minval=0, maxval=1)\n\n        theta_j = get_theta(\n            F=lambda theta: F_j(theta, j, d),\n            a=0,\n            b=jnp.pi,\n            x=x,\n            eps=1e-9,\n        )\n\n        theta = theta.at[j].set(theta_j)\n\n    # e2 has dimension d\n    e2: Array = jnp.ones(d)\n\n    # e2[1] to e2[d-1] have products of sin(theta) terms\n    # TODO: vectorize this loop\n    for j in range(1, d):\n        e2 = e2.at[j].set(e2[j - 1] * jnp.sin(theta[j - 1]))\n\n    theta = jnp.append(theta, 0)  # Append 0 for cos(0) of last coordinate\n\n    # e2[d] has additional cos(theta) term in product\n    e2 = e2 * jnp.cos(theta)\n\n    return theta, e2\n</code></pre>"},{"location":"orthonormal/","title":"<code>orthonormal</code>","text":"<p>This module contains functions to calculate the orthonormal basis representing the hyperplane $\\Pi$ that is tangential to the hypersphere $S_{d-1}$ representing the input state.</p>"},{"location":"orthonormal/#isotropic.orthonormal","title":"<code>isotropic.orthonormal</code>","text":"<p>This module contains functions for constructing orthonormal basis of Pi.</p>"},{"location":"orthonormal/#isotropic.orthonormal.get_orthonormal_basis","title":"<code>get_orthonormal_basis(Phi)</code>","text":"<p>Construct an orthonormal basis given a point $\\Phi$ on a unit sphere.</p> <p>The point $\\Phi$ is given by a d+1 dimensional vector and the orthonormal basis consists of d vectors each of dimension d+1, which are orthogonal to $\\Phi$ and to each other.</p> <p>Parameters:</p> Name Type Description Default <code>Phi</code> <code>ArrayLike</code> <p>A point on the unit sphere, should be a normalized vector.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>An orthonormal basis of dimension (d, d+1).</p> Source code in <code>src/isotropic/orthonormal.py</code> <pre><code>def get_orthonormal_basis(Phi: ArrayLike) -&gt; Array:\n    \"\"\"\n    Construct an orthonormal basis given a point $\\\\Phi$ on a unit sphere.\n\n    The point $\\\\Phi$ is given by a d+1 dimensional vector and the orthonormal basis consists of d vectors\n    each of dimension d+1, which are orthogonal to $\\\\Phi$ and to each other.\n\n    Parameters\n    ----------\n    Phi : ArrayLike\n        A point on the unit sphere, should be a normalized vector.\n\n    Returns\n    -------\n    Array\n        An orthonormal basis of dimension (d, d+1).\n    \"\"\"\n    Phi = jnp.array(Phi)\n    dim = len(Phi)  # d+1\n\n    # Verify Phi is normalized (within numerical precision)\n    norm_phi = jnp.linalg.norm(Phi)\n    Phi = jnp.where(jnp.abs(norm_phi - 1.0) &gt; 1e-10, Phi / norm_phi, Phi)\n\n    if Phi[0] != 0 or Phi[1] != 0:\n        v1 = jnp.array([Phi[1], -Phi[0]])\n    else:\n        v1 = jnp.array([1.0, 0.0])\n\n    v1 = v1 / jnp.linalg.norm(v1)\n    v1 = jnp.pad(v1, (0, dim - 2), mode=\"constant\", constant_values=0)\n\n    basis_vectors = v1.reshape(1, -1)\n\n    for i in range(2, dim):\n        A = jnp.vstack([basis_vectors[:, : i + 1], Phi[: i + 1]])\n        x = jax_null_space(A).squeeze()\n        x = x / jnp.linalg.norm(x)\n        x = jnp.pad(x, (0, dim - len(x)), mode=\"constant\", constant_values=0)\n        basis_vectors = jnp.vstack([basis_vectors, x])\n\n    return basis_vectors\n</code></pre>"},{"location":"thetazero/","title":"<code>thetazero</code>","text":"<p>This module contains functions to calculate the angle $\\theta_0$ with a normal distribution.</p>"},{"location":"thetazero/#isotropic.thetazero","title":"<code>isotropic.thetazero</code>","text":"<p>This module contains functions for generating $\\theta_0$.</p>"},{"location":"thetazero/#isotropic.thetazero.get_theta_zero","title":"<code>get_theta_zero(x, g)</code>","text":"<p>Calculate the inverse angle $\\theta_0$ with a normal distribution given a value x.</p> <p>This function finds the angle $\\theta_0$ such that the integral of g from 0 to $\\theta_0$ equals x. It uses Simpson's rule for numerical integration and a bisection method to find the root.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ArrayLike</code> <p>Value for which to find the inverse, should be uniformly distributed in $[0, 1]$.</p> required <code>g</code> <code>Callable</code> <p>Function $g(\\theta)$ that is integrated to calculate $F(\\theta)$.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Value of $\\theta_0$.</p> Source code in <code>src/isotropic/thetazero.py</code> <pre><code>def get_theta_zero(x: ArrayLike, g: Callable) -&gt; float:\n    \"\"\"\n    Calculate the inverse angle $\\\\theta_0$ with a normal distribution given a value x.\n\n    This function finds the angle $\\\\theta_0$ such that the integral of g from 0 to $\\\\theta_0$ equals x.\n    It uses Simpson's rule for numerical integration and a bisection method to find the root.\n\n    Parameters\n    ----------\n    x : ArrayLike\n        Value for which to find the inverse, should be uniformly distributed in $[0, 1]$.\n    g : Callable\n        Function $g(\\\\theta)$ that is integrated to calculate $F(\\\\theta)$.\n\n    Returns\n    -------\n    float\n        Value of $\\\\theta_0$.\n    \"\"\"\n\n    # We wrap the function g into a callable F that integrates g from 0 to theta.\n    def F(theta: float) -&gt; Array:\n        # TODO: Provide the correct value for C based on the 4th derivative bound\n        return simpsons_rule(g, 0, theta, 1, 1e-9)\n\n    # Use bisection to find theta_0 such that the integral equals x\n    theta_zero: float = get_theta(F, 0, jnp.pi, x, 1e-9)\n\n    return theta_zero\n</code></pre>"},{"location":"utils/","title":"<code>utils</code>","text":"<p>This module contains miscellaneous utilities useful for various steps involved in the isotropic error generation.</p>"},{"location":"utils/#isotropic.utils","title":"<code>isotropic.utils</code>","text":""},{"location":"utils/#isotropic.utils.bisection","title":"<code>bisection</code>","text":"<p>This module contains functions for the bisection algorithm to calculate $F^{-1}$</p>"},{"location":"utils/#isotropic.utils.bisection.get_theta","title":"<code>get_theta(F, a, b, x, eps)</code>","text":"<p>Finds the value of theta such that $F(\\theta) = x$ using the bisection method. This function assumes that $F$ is an increasing function in the interval $[a, b]$ and that $F(a) \\leq x \\leq F(b)$.</p> <p>The bisection method is a root-finding method that repeatedly bisects an interval and then selects a subinterval in which a root exists.</p> <p>Parameters:</p> Name Type Description Default <code>F</code> <code>Callable</code> <p>Function for which to compute the inverse.</p> required <code>a</code> <code>float</code> <p>Lower bound of the interval.</p> required <code>b</code> <code>float</code> <p>Upper bound of the interval.</p> required <code>x</code> <code>float | ArrayLike</code> <p>Value for which to find the inverse.</p> required <code>eps</code> <code>float</code> <p>Tolerance for convergence.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The value of $theta$ such that $F(\\theta) = x$.</p> Source code in <code>src/isotropic/utils/bisection.py</code> <pre><code>def get_theta(\n    F: Callable, a: float, b: float, x: float | ArrayLike, eps: float\n) -&gt; float:\n    \"\"\"\n    Finds the value of theta such that $F(\\\\theta) = x$ using the bisection method.\n    This function assumes that $F$ is an increasing function in the interval $[a, b]$\n    and that $F(a) \\\\leq x \\\\leq F(b)$.\n\n    The bisection method is a root-finding method that repeatedly bisects an interval\n    and then selects a subinterval in which a root exists.\n\n    Parameters\n    ----------\n    F : Callable\n        Function for which to compute the inverse.\n    a : float\n        Lower bound of the interval.\n    b : float\n        Upper bound of the interval.\n    x : float | ArrayLike\n        Value for which to find the inverse.\n    eps : float\n        Tolerance for convergence.\n\n    Returns\n    -------\n    float\n        The value of $theta$ such that $F(\\\\theta) = x$.\n    \"\"\"\n    while b - a &gt; eps:\n        c = (a + b) / 2.0\n        Fc = F(c)\n        if Fc &lt;= x:\n            a = c\n        else:\n            b = c\n    return (a + b) / 2.0\n</code></pre>"},{"location":"utils/#isotropic.utils.distribution","title":"<code>distribution</code>","text":"<p>This module contains functions for relevant probability distributions</p>"},{"location":"utils/#isotropic.utils.distribution.double_factorial_jax","title":"<code>double_factorial_jax(n)</code>","text":"<p>Helper function to compute double factorial:</p> <pre><code>n!! = n * (n-2) * (n-4) * ... * 1 (if n is odd) or 2 (if n is even).\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The integer for which to compute the double factorial.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>The value of the double factorial n!!</p> Source code in <code>src/isotropic/utils/distribution.py</code> <pre><code>def double_factorial_jax(n: int) -&gt; Array:\n    \"\"\"\n    Helper function to compute double factorial:\n\n        n!! = n * (n-2) * (n-4) * ... * 1 (if n is odd) or 2 (if n is even).\n\n    Parameters\n    ----------\n    n : int\n        The integer for which to compute the double factorial.\n\n    Returns\n    -------\n    Array\n        The value of the double factorial n!!\n    \"\"\"\n    # works for numbers as large as 9**6\n    return jnp.where(n &lt;= 0, 1, jnp.prod(jnp.arange(n, 0, -2, dtype=jnp.uint64)))\n</code></pre>"},{"location":"utils/#isotropic.utils.distribution.double_factorial_ratio_jax","title":"<code>double_factorial_ratio_jax(num, den)</code>","text":"<p>Computes the ratio of double factorials:</p> <pre><code>num!! / den!!\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>num</code> <code>int</code> <p>The numerator for the double factorial.</p> required <code>den</code> <code>int</code> <p>The denominator for the double factorial.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>The value of the ratio num!! / den!!</p> Notes <p>For very large numbers, this is numerically stable only when |num - den| ~5.</p> Source code in <code>src/isotropic/utils/distribution.py</code> <pre><code>def double_factorial_ratio_jax(num: int, den: int) -&gt; Array:\n    \"\"\"\n    Computes the ratio of double factorials:\n\n        num!! / den!!\n\n    Parameters\n    ----------\n    num : int\n        The numerator for the double factorial.\n    den : int\n        The denominator for the double factorial.\n\n    Returns\n    -------\n    Array\n        The value of the ratio num!! / den!!\n\n    Notes\n    -----\n    For very large numbers, this is numerically stable only when |num - den| ~5.\n    \"\"\"\n    warnings.warn(\n        \"This is an experimental implementation. There are known issues with using this for numbers larger than 2**8\",\n        UserWarning,\n    )\n    if abs(num - den) &gt; 4:\n        raise ValueError(\"num and den should be close to each other\")\n    num_elems = jnp.arange(num, 0, -2, dtype=jnp.uint64)\n    den_elems = jnp.arange(den, 0, -2, dtype=jnp.uint64)\n\n    len_diff = den_elems.shape[0] - num_elems.shape[0]\n\n    # Ensure both num_elems and den_elems have the same length\n    if len_diff &gt; 0:\n        num_elems = jnp.concatenate((num_elems, jnp.ones(len_diff, dtype=jnp.uint64)))\n    else:\n        den_elems = jnp.concatenate((den_elems, jnp.ones(-len_diff, dtype=jnp.uint64)))\n\n    num_len = num_elems.shape[0]\n    den_len = den_elems.shape[0]\n\n    ratio_elems = jnp.zeros(num_len // 2)\n\n    for k in jnp.arange(0, num_len // 2, 1):\n        ratio_elems = ratio_elems.at[k].set(\n            (num_elems[k] * num_elems[num_len - 1 - k])\n            / (den_elems[k] * den_elems[den_len - 1 - k])\n        )\n    ratio = jnp.prod(ratio_elems)\n    return ratio\n</code></pre>"},{"location":"utils/#isotropic.utils.distribution.double_factorial_ratio_scipy","title":"<code>double_factorial_ratio_scipy(num, den)</code>","text":"<p>Compute the ratio of double factorials num!! / den!!.</p> <p>Parameters:</p> Name Type Description Default <code>num</code> <code>int</code> <p>The numerator double factorial.</p> required <code>den</code> <code>int</code> <p>The denominator double factorial.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The ratio of the double factorials.</p> Notes <p>This only works for numbers up to 300.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If num or den is greater than 300.</p> Source code in <code>src/isotropic/utils/distribution.py</code> <pre><code>def double_factorial_ratio_scipy(num: int, den: int) -&gt; float:\n    \"\"\"\n    Compute the ratio of double factorials num!! / den!!.\n\n    Parameters\n    ----------\n    num : int\n        The numerator double factorial.\n    den : int\n        The denominator double factorial.\n\n    Returns\n    -------\n    float\n        The ratio of the double factorials.\n\n    Notes\n    -----\n    This only works for numbers up to 300.\n\n    Raises\n    ------\n    ValueError\n        If num or den is greater than 300.\n    \"\"\"\n    if num &gt; 300 or den &gt; 300:\n        raise ValueError(\"This only works for numbers up to 300\")\n    return factorial2(num) / factorial2(den)\n</code></pre>"},{"location":"utils/#isotropic.utils.distribution.normal_integrand","title":"<code>normal_integrand(theta, d, sigma)</code>","text":"<p>Computes the function g(\u03b8) that is integrated to calculate F(\u03b8) which is the distribution function for the angle \u03b8 in a normal distribution:</p> <p>$$g(\\theta) = \\frac{(d-1)!! \\times (1-\\sigma^2) \\times \\sin^{d-1}(\\theta)}{\\pi \\times (d-2)!! \\times (1+\\sigma^2-2\\sigma\\cos(\\theta))^{(d+1)/2}}$$</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>float</code> <p>Angle parameter(s).</p> required <code>d</code> <code>int</code> <p>Dimension parameter.</p> required <code>sigma</code> <code>float</code> <p>Sigma parameter (should be in valid range).</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Value(s) of the function evaluated at <code>theta</code>.</p> Source code in <code>src/isotropic/utils/distribution.py</code> <pre><code>def normal_integrand(theta: float, d: int, sigma: float) -&gt; Array:\n    \"\"\"\n    Computes the function g(\u03b8) that is integrated to calculate F(\u03b8) which is the\n    distribution function for the angle \u03b8 in a normal distribution:\n\n    $$g(\\\\theta) = \\\\frac{(d-1)!! \\\\times (1-\\\\sigma^2) \\\\times \\\\sin^{d-1}(\\\\theta)}{\\\\pi \\\\times (d-2)!! \\\\times (1+\\\\sigma^2-2\\\\sigma\\\\cos(\\\\theta))^{(d+1)/2}}$$\n\n    Parameters\n    ----------\n    theta : float\n        Angle parameter(s).\n    d : int\n        Dimension parameter.\n    sigma : float\n        Sigma parameter (should be in valid range).\n\n    Returns\n    -------\n    Array\n        Value(s) of the function evaluated at `theta`.\n    \"\"\"\n\n    # TODO: Convert inputs to JAX arrays once @jit works\n    # theta = jnp.asarray(theta)\n    # d = jnp.asarray(d, dtype=jnp.int32)\n    # sigma = jnp.asarray(sigma)\n\n    # factorial components\n    numerator_factorial = factorial2(d - 1)\n    denominator_factorial = factorial2(d - 2)\n\n    # Numerator components\n    one_minus_sigma_sq = 1.0 - sigma**2\n    sin_theta_power = jnp.power(jnp.sin(theta), d - 1)\n\n    # Denominator components\n    denominator_base = 1.0 + sigma**2 - 2.0 * sigma * jnp.cos(theta)\n    denominator_power = jnp.power(denominator_base, (d + 1) / 2.0)\n\n    # Combine all terms\n    numerator = numerator_factorial * one_minus_sigma_sq * sin_theta_power\n    denominator = jnp.pi * denominator_factorial * denominator_power\n\n    result = numerator / denominator\n\n    return result\n</code></pre>"},{"location":"utils/#isotropic.utils.linalg","title":"<code>linalg</code>","text":""},{"location":"utils/#isotropic.utils.linalg.jax_null_space","title":"<code>jax_null_space(A)</code>","text":"<p>Compute the null space of a matrix $A$ using JAX.</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>ArrayLike</code> <p>The input matrix for which to compute the null space.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>The basis vectors of the null space of A.</p> Notes <p>See also:</p> <ul> <li><code>scipy.linalg.null_space</code> for the reference implementation in SciPy.</li> <li>https://github.com/jax-ml/jax/pull/14486 for an old JAX implementation.</li> </ul> Source code in <code>src/isotropic/utils/linalg.py</code> <pre><code>def jax_null_space(A: ArrayLike) -&gt; Array:\n    \"\"\"\n    Compute the null space of a matrix $A$ using JAX.\n\n    Parameters\n    ----------\n    A : ArrayLike\n        The input matrix for which to compute the null space.\n\n    Returns\n    -------\n    Array\n        The basis vectors of the null space of A.\n\n    Notes\n    ------\n    See also:\n\n    - `scipy.linalg.null_space` for the reference implementation in SciPy.\n    - [https://github.com/jax-ml/jax/pull/14486](https://github.com/jax-ml/jax/pull/14486) for an old JAX implementation.\n    \"\"\"\n    u, s, vh = svd(A, full_matrices=True)\n    M, N = u.shape[0], vh.shape[1]\n    rcond = jnp.finfo(s.dtype).eps * max(M, N)\n    tol = jnp.amax(s, initial=0.0) * rcond\n    num = jnp.sum(s &gt; tol, dtype=int)\n    Q = vh[num:, :].T.conj()\n    return Q\n</code></pre>"},{"location":"utils/#isotropic.utils.simpsons","title":"<code>simpsons</code>","text":"<p>This module contains functions for estimating the integral of a function using Simpson's rule.</p>"},{"location":"utils/#isotropic.utils.simpsons.simpsons_rule","title":"<code>simpsons_rule(f, a, b, C, tol)</code>","text":"<p>Estimates the integral of a function using Simpson's rule.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable</code> <p>Function to integrate.</p> required <code>a</code> <code>float</code> <p>Lower limit of integration.</p> required <code>b</code> <code>float</code> <p>Upper limit of integration.</p> required <code>C</code> <code>float</code> <p>Bound on 4th derivative of f.</p> required <code>tol</code> <code>float</code> <p>Desired tolerance for the integral estimate.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Estimated value of the integral.</p> Source code in <code>src/isotropic/utils/simpsons.py</code> <pre><code>def simpsons_rule(f: Callable, a: float, b: float, C: float, tol: float) -&gt; Array:\n    \"\"\"\n    Estimates the integral of a function using Simpson's rule.\n\n    Parameters\n    ----------\n    f : Callable\n        Function to integrate.\n    a : float\n        Lower limit of integration.\n    b : float\n        Upper limit of integration.\n    C : float\n        Bound on 4th derivative of f.\n    tol : float\n        Desired tolerance for the integral estimate.\n\n    Returns\n    -------\n    Array\n        Estimated value of the integral.\n    \"\"\"\n    # Estimate minimum number of intervals needed for given tolerance\n    n: int = int(jnp.ceil(((180 * tol) / (C * (b - a) ** 5)) ** (-0.25)))\n    if n % 2 == 1:\n        n += 1  # Simpson's rule requires even n\n\n    x: Array = jnp.linspace(a, b, n + 1)\n    y: Array = f(x)\n\n    S: Array = y[0] + y[-1] + 4 * jnp.sum(y[1:-1:2]) + 2 * jnp.sum(y[2:-2:2])\n    integral: Array = (b - a) / (3 * n) * S\n    return integral\n</code></pre>"},{"location":"utils/#isotropic.utils.state_transforms","title":"<code>state_transforms</code>","text":"<p>This module contains functions for transforming the quantum state</p>"},{"location":"utils/#isotropic.utils.state_transforms.add_isotropic_error","title":"<code>add_isotropic_error(Phi_sp, e2, theta_zero)</code>","text":"<p>Add isotropic error to state $\\Phi$ given $e_2$ and $\\theta_0$</p> <p>Parameters:</p> Name Type Description Default <code>Phi_sp</code> <code>ArrayLike</code> <p>state to which isotropic error is added (in spherical form)</p> required <code>e2</code> <code>ArrayLike</code> <p>vector $e_2$ in $S_{d-1}$ with uniform distribution</p> required <code>theta_zero</code> <code>float</code> <p>angle $\\theta_0$ in $[0,\\pi]$ with density function $f(\\theta_0)$</p> required <p>Returns:</p> Type Description <code>Array</code> <p>statevector in spherical form after adding isotropic error</p> Source code in <code>src/isotropic/utils/state_transforms.py</code> <pre><code>def add_isotropic_error(Phi_sp: Array, e2: Array, theta_zero: float) -&gt; Array:\n    \"\"\"\n    Add isotropic error to state $\\\\Phi$ given $e_2$ and $\\\\theta_0$\n\n    Parameters\n    ----------\n    Phi_sp : ArrayLike\n        state to which isotropic error is added (in spherical form)\n    e2 : ArrayLike\n        vector $e_2$ in $S_{d-1}$ with uniform distribution\n    theta_zero : float\n        angle $\\\\theta_0$ in $[0,\\\\pi]$ with density function $f(\\\\theta_0)$\n\n    Returns\n    -------\n    Array\n        statevector in spherical form after adding isotropic error\n    \"\"\"\n    Psi_sp = (Phi_sp * jnp.cos(theta_zero)) + (\n        (jnp.sum(e2, axis=0)) * jnp.sin(theta_zero)\n    )\n    return Psi_sp\n</code></pre>"},{"location":"utils/#isotropic.utils.state_transforms.generate_and_add_isotropic_error","title":"<code>generate_and_add_isotropic_error(Phi, sigma=0.9, key=random.PRNGKey(0))</code>","text":"<p>Generate and add isotropic error to a given statevector.</p> <p>Parameters:</p> Name Type Description Default <code>Phi</code> <code>ArrayLike</code> <p>The input statevector as a complex JAX array of dimension $2^n$, for n-qubits.</p> required <code>sigma</code> <code>float</code> <p>The standard deviation for the isotropic error, by default 0.9.</p> <code>0.9</code> <code>key</code> <code>ArrayLike</code> <p>Random key for reproducibility, by default random.PRNGKey(0).</p> <code>PRNGKey(0)</code> <p>Returns:</p> Type Description <code>Array</code> <p>The perturbed statevector after adding isotropic error.</p> Source code in <code>src/isotropic/utils/state_transforms.py</code> <pre><code>def generate_and_add_isotropic_error(\n    Phi: ArrayLike, sigma: float = 0.9, key: ArrayLike = random.PRNGKey(0)\n) -&gt; Array:\n    \"\"\"\n    Generate and add isotropic error to a given statevector.\n\n    Parameters\n    ----------\n    Phi : ArrayLike\n        The input statevector as a complex JAX array of dimension $2^n$, for n-qubits.\n    sigma : float, optional\n        The standard deviation for the isotropic error, by default 0.9.\n    key : ArrayLike, optional\n        Random key for reproducibility, by default random.PRNGKey(0).\n\n    Returns\n    -------\n    Array\n        The perturbed statevector after adding isotropic error.\n    \"\"\"\n    Phi_spherical = statevector_to_hypersphere(Phi)\n    basis = get_orthonormal_basis(\n        Phi_spherical\n    )  # gives d vectors with d+1 elements each\n    _, coeffs = get_e2_coeffs(\n        d=basis.shape[0],  # gives d coefficients for the d vectors above\n        F_j=F_j,\n        key=key,\n    )\n    e2 = jnp.expand_dims(coeffs, axis=-1) * basis\n\n    def g(theta):\n        return normal_integrand(theta, d=Phi_spherical.shape[0], sigma=sigma)\n\n    x = random.uniform(key, shape=(), minval=0, maxval=1)\n    theta_zero = get_theta_zero(x=x, g=g)\n    Psi_spherical = add_isotropic_error(Phi_spherical, e2=e2, theta_zero=theta_zero)\n    Psi = hypersphere_to_statevector(Psi_spherical)\n    return Psi\n</code></pre>"},{"location":"utils/#isotropic.utils.state_transforms.hypersphere_to_statevector","title":"<code>hypersphere_to_statevector(S)</code>","text":"<p>Generate the statevector $\\Phi$ from hypersphere $S$</p> <p>Parameters:</p> Name Type Description Default <code>S</code> <code>Array</code> <p>hypersphere as a real JAX array of dimension $2^{n+1}$ for n qubits</p> required <p>Returns:</p> Type Description <code>Array</code> <p>statevector as a complex JAX array of dimension $2^n$</p> Source code in <code>src/isotropic/utils/state_transforms.py</code> <pre><code>def hypersphere_to_statevector(S: Array) -&gt; Array:\n    \"\"\"\n    Generate the statevector $\\\\Phi$ from hypersphere $S$\n\n    Parameters\n    ----------\n    S: ArrayLike\n        hypersphere as a real JAX array of dimension $2^{n+1}$ for n qubits\n\n    Returns\n    -------\n    Array\n        statevector as a complex JAX array of dimension $2^n$\n    \"\"\"\n    Phi = jnp.zeros(int(2 ** (log(S.shape[0], 2) - 1)), dtype=complex)\n    for x in range(Phi.shape[0]):\n        Phi = Phi.at[x].set(S[2 * x] + 1j * S[2 * x + 1])\n    return Phi\n</code></pre>"},{"location":"utils/#isotropic.utils.state_transforms.statevector_to_hypersphere","title":"<code>statevector_to_hypersphere(Phi)</code>","text":"<p>Generate the hypersphere from statevector $\\Phi$</p> <p>Parameters:</p> Name Type Description Default <code>Phi</code> <code>Array</code> <p>statevector as a complex JAX array of dimension $2^n$, for n-qubits</p> required <p>Returns:</p> Type Description <code>Array</code> <p>hypersphere as a real JAX array of dimension $2^{n+1}$</p> Source code in <code>src/isotropic/utils/state_transforms.py</code> <pre><code>def statevector_to_hypersphere(Phi: Array) -&gt; Array:\n    \"\"\"\n    Generate the hypersphere from statevector $\\\\Phi$\n\n    Parameters\n    ----------\n    Phi: ArrayLike\n        statevector as a complex JAX array of dimension $2^n$, for n-qubits\n\n    Returns\n    -------\n    Array\n        hypersphere as a real JAX array of dimension $2^{n+1}$\n    \"\"\"\n    S = jnp.zeros(int(2 ** (log(Phi.shape[0], 2) + 1)), dtype=float)\n    for x in range(S.shape[0] // 2):\n        S = S.at[2 * x].set(Phi[x].real)\n        S = S.at[2 * x + 1].set(Phi[x].imag)\n    return S\n</code></pre>"}]}