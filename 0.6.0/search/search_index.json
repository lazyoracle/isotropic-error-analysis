{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to <code>isotropic</code>","text":"<p><code>isotropic</code> is a python package for isotropic error analysis in quantum computing. The library provides a comprehensive set of tools to model and generate isotropic errors to test their effect on various quantum algorithms.</p> <p>Broadly this involves the following steps:</p> <ol> <li>Construct an orthonormal basis of $\\Pi$ with center at $\\Phi$.</li> <li>Generate a vector $e_2$ in $S_{d\u22121}$ with uniform distribution.</li> <li>Generate an angle $\\theta_0$ in $[0,\\pi]$ with density function $f(\\theta_0)$.</li> <li>Generate the final perturbed state $\\Psi$ as a rotation of $e_1 = \\Phi$ by angle $\\theta_0$ in the subspace spanned by the orthonormal basis $[e_1,e_2]$ using the expression $$\\Psi = \\Phi \\cos(\\theta_0) + e_2 \\sin(\\theta_0)$$</li> </ol>"},{"location":"#installation","title":"Installation","text":"<p>You can install <code>isotropic</code> from <code>pip</code> with:</p> <pre><code>pip install isotropic\n</code></pre> <p>If you want to test the effect of isotropic errors with one of the included quantum algorithm implementations, consider installing with the <code>all</code> option as such:</p> <pre><code>pip install isotropic\\[all\\]\n</code></pre>"},{"location":"#api-reference","title":"API Reference","text":"<p>This library provides modules to perform each of the steps outlined above. See below for the API reference:</p> <ul> <li>Algorithms</li> <li>Coefficients of e2</li> <li>Orthonormal basis</li> <li>Theta Zero</li> <li>Utilities</li> </ul>"},{"location":"algos/","title":"<code>algos</code>","text":"<p>This module contains Qiskit implementations of example algorithms to analyse the effects of isotropic errors.</p>"},{"location":"algos/#isotropic.algos","title":"<code>isotropic.algos</code>","text":""},{"location":"algos/#isotropic.algos.grover","title":"<code>grover</code>","text":""},{"location":"algos/#isotropic.algos.grover.get_grover_answer","title":"<code>get_grover_answer(result)</code>","text":"<p>Extract the measurement counts from the result of a Grover circuit execution.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>PrimitiveResult</code> <p>The result object returned by executing the Grover circuit.</p> required <p>Returns:</p> Type Description <code>tuple[dict, str]</code> <p>A tuple containing the counts dictionary and the most probable search item.</p> Source code in <code>src/isotropic/algos/grover.py</code> <pre><code>def get_grover_answer(result: PrimitiveResult) -&gt; tuple[dict, str]:\n    \"\"\"\n    Extract the measurement counts from the result of a Grover circuit execution.\n\n    Parameters\n    ----------\n    result : PrimitiveResult\n        The result object returned by executing the Grover circuit.\n\n    Returns\n    -------\n    tuple[dict, str]\n        A tuple containing the counts dictionary and the most probable search item.\n    \"\"\"\n    if not isinstance(result, PrimitiveResult):\n        raise TypeError(\"The result must be an instance of PrimitiveResult.\")\n\n    counts = result[0].data.c0.get_counts()\n    grover_answer = max(counts, key=counts.get)\n\n    return counts, grover_answer\n</code></pre>"},{"location":"algos/#isotropic.algos.grover.get_grover_circuit","title":"<code>get_grover_circuit(num_qubits, U_w, iterations)</code>","text":"<p>Create a Grover circuit with the given number of qubits, oracle, and iterations.</p> <p>Parameters:</p> Name Type Description Default <code>num_qubits</code> <code>int</code> <p>The number of qubits used to encode the states.</p> required <code>U_w</code> <code>Operator</code> <p>The oracle that marks the solution states.</p> required <code>iterations</code> <code>int</code> <p>The number of Grover iterations to perform.</p> required <p>Returns:</p> Type Description <code>QuantumCircuit</code> <p>The constructed Grover quantum circuit.</p> Source code in <code>src/isotropic/algos/grover.py</code> <pre><code>def get_grover_circuit(\n    num_qubits: int, U_w: Operator, iterations: int\n) -&gt; QuantumCircuit:\n    \"\"\"\n    Create a Grover circuit with the given number of qubits, oracle, and iterations.\n\n    Parameters\n    ----------\n    num_qubits : int\n        The number of qubits used to encode the states.\n    U_w : Operator\n        The oracle that marks the solution states.\n    iterations : int\n        The number of Grover iterations to perform.\n\n    Returns\n    -------\n    QuantumCircuit\n        The constructed Grover quantum circuit.\n    \"\"\"\n\n    if U_w.num_qubits != num_qubits:\n        raise ValueError(\n            \"Oracle U_w must have the same number of qubits as num_qubits.\"\n        )\n\n    qr = QuantumRegister(num_qubits)\n    cr = ClassicalRegister(num_qubits)\n    qcirc = QuantumCircuit(qr, cr)\n\n    # Initializing the circuit\n    for i in range(num_qubits):\n        qcirc.h(i)\n\n    for i in range(iterations):\n        qcirc.barrier()\n\n        # Oracle to introduce negative phase (circuit of above matrix)\n        qcirc.append(U_w, qr)\n\n        qcirc.barrier()\n\n        # Diffusion operator\n        for qubit in range(num_qubits):\n            qcirc.h(qubit)\n        for qubit in range(num_qubits):\n            qcirc.x(qubit)\n        qcirc.h(num_qubits - 1)\n        qcirc.mcx(list(range(num_qubits - 1)), num_qubits - 1)\n        qcirc.h(num_qubits - 1)\n        for qubit in range(num_qubits):\n            qcirc.x(qubit)\n        for qubit in range(num_qubits):\n            qcirc.h(qubit)\n\n    return qcirc\n</code></pre>"},{"location":"algos/#isotropic.algos.grover.optimal_num_iterations","title":"<code>optimal_num_iterations(num_solutions, num_qubits)</code>","text":"<p>Return the optimal number of iterations, if the number of solutions is known.</p> <p>Parameters:</p> Name Type Description Default <code>num_solutions</code> <code>int</code> <p>The number of solutions.</p> required <code>num_qubits</code> <code>int</code> <p>The number of qubits used to encode the states.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The optimal number of iterations for Grover's algorithm to succeed.</p> Source code in <code>src/isotropic/algos/grover.py</code> <pre><code>def optimal_num_iterations(num_solutions: int, num_qubits: int) -&gt; int:\n    \"\"\"\n    Return the optimal number of iterations, if the number of solutions is known.\n\n    Parameters\n    ----------\n    num_solutions : int\n        The number of solutions.\n    num_qubits : int\n        The number of qubits used to encode the states.\n\n    Returns\n    -------\n    int\n        The optimal number of iterations for Grover's algorithm to succeed.\n    \"\"\"\n    amplitude = jnp.sqrt(num_solutions / 2**num_qubits)\n    return round(jnp.arccos(amplitude) / (2 * jnp.arcsin(amplitude)))\n</code></pre>"},{"location":"e2/","title":"<code>e2</code>","text":"<p>This module contains functions to calculate the coefficients which are multipled with the orthonormal basis to make up the $e_2$ vector.</p>"},{"location":"e2/#isotropic.e2","title":"<code>isotropic.e2</code>","text":"<p>This module contains functions for generating the vector $e_2$.</p>"},{"location":"e2/#isotropic.e2.F_j","title":"<code>F_j(theta_j, j, d)</code>","text":"<p>Calculate the function $F_j$ for the given angle $\\theta_j$ and index $j$ in dimension $d$.</p> <p>Parameters:</p> Name Type Description Default <code>theta_j</code> <code>float</code> <p>The angle at which to evaluate the function.</p> required <code>j</code> <code>int</code> <p>The index corresponding to the angle.</p> required <code>d</code> <code>int</code> <p>The dimension of the space.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>The value of the function $F_j$ evaluated at $\\theta_j$.</p> Source code in <code>src/isotropic/e2.py</code> <pre><code>def F_j(theta_j: float, j: int, d: int) -&gt; Array:\n    \"\"\"\n    Calculate the function $F_j$ for the given angle $\\\\theta_j$ and index $j$ in dimension $d$.\n\n    Parameters\n    ----------\n    theta_j : float\n        The angle at which to evaluate the function.\n    j : int\n        The index corresponding to the angle.\n    d : int\n        The dimension of the space.\n\n    Returns\n    -------\n    Array\n        The value of the function $F_j$ evaluated at $\\\\theta_j$.\n    \"\"\"\n    dj = d - j\n\n    def F_odd(_):\n        C_j = (1 / 2) * double_factorial_ratio(dj - 1, dj - 2)\n        prefactor = 1 / 2\n        k_max = (dj - 2) // 2  # upper bound for k in range\n        k_vals = np.arange(0, k_max + 1)\n\n        def product_term(k):\n            num_list = list(range(d - j - 2, (2 * k + 2) - 1, -2))\n            den_list = list(range(d - j - 1, (2 * k + 1) - 1, -2))\n            # make sure both lists are the same length by padding the shorter one with 1s\n            max_len = max(len(num_list), len(den_list))\n            num_list += [1] * (max_len - len(num_list))\n            den_list += [1] * (max_len - len(den_list))\n            num_array = np.array(num_list)\n            den_array = np.array(den_list)\n\n            def ratio(a, b):\n                return a / b\n\n            result_array = np.vectorize(ratio)(num_array, den_array)\n            fraction = np.prod(result_array)\n            return fraction * jnp.sin(theta_j) ** (2 * k)\n\n        sum_terms = np.vectorize(product_term)(k_vals).sum()\n        return prefactor - (C_j * jnp.cos(theta_j) * sum_terms)\n\n    def F_even(_):\n        C_j = (1 / jnp.pi) * double_factorial_ratio(dj - 1, dj - 2)\n        prefactor = theta_j / jnp.pi\n        k_max = (dj - 1) // 2\n        k_vals = np.arange(1, k_max + 1)\n\n        def product_term(k):\n            num_list = list(range(d - j - 2, (2 * k + 1) - 1, -2))\n            den_list = list(range(d - j - 1, (2 * k) - 1, -2))\n            # make sure both lists are the same length by padding the shorter one with 1s\n            max_len = max(len(num_list), len(den_list))\n            num_list += [1] * (max_len - len(num_list))\n            den_list += [1] * (max_len - len(den_list))\n            num_array = np.array(num_list)\n            den_array = np.array(den_list)\n\n            def ratio(a, b):\n                return a / b\n\n            result_array = np.vectorize(ratio)(num_array, den_array)\n            fraction = np.prod(result_array)\n            return fraction * jnp.sin(theta_j) ** (2 * k - 1)\n\n        sum_terms = np.vectorize(product_term)(k_vals).sum()\n        return prefactor - (C_j * jnp.cos(theta_j) * sum_terms)\n\n    # TODO: Use a conditional to choose between F_odd and F_even based on j\n    # return lax.cond(j % 2 == 1, F_odd, F_even, operand=None)\n    if j % 2 == 1:\n        return F_odd(None)\n    else:\n        return F_even(None)\n</code></pre>"},{"location":"e2/#isotropic.e2.get_e2_coeffs","title":"<code>get_e2_coeffs(d, F_j, key=random.PRNGKey(0))</code>","text":"<p>Generate the coefficients of the vector $e_2$.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>int</code> <p>Dimension of the space.</p> required <code>F_j</code> <code>Callable</code> <p>Function to compute $F_j$ for the given angle, dimension and index.</p> required <code>key</code> <code>ArrayLike</code> <p>Random key for reproducibility, by default random.PRNGKey(0).</p> <code>PRNGKey(0)</code> <p>Returns:</p> Type Description <code>Tuple[Array, Array]</code> <p>A tuple containing:</p> <ul> <li>theta: Array of angles used to construct $e_2$.</li> <li>e2: Array representing the coefficients of the vector $e_2$.</li> </ul> Source code in <code>src/isotropic/e2.py</code> <pre><code>def get_e2_coeffs(\n    d: int, F_j: Callable, key: ArrayLike = random.PRNGKey(0)\n) -&gt; Tuple[Array, Array]:\n    \"\"\"\n    Generate the coefficients of the vector $e_2$.\n\n    Parameters\n    ----------\n    d : int\n        Dimension of the space.\n    F_j : Callable\n        Function to compute $F_j$ for the given angle, dimension and index.\n    key : ArrayLike, optional\n        Random key for reproducibility, by default random.PRNGKey(0).\n\n    Returns\n    -------\n    Tuple[Array, Array]\n        A tuple containing:\n\n        - theta: Array of angles used to construct $e_2$.\n        - e2: Array representing the coefficients of the vector $e_2$.\n    \"\"\"\n    theta: Array = jnp.zeros(d - 1)\n\n    # Generate theta_{d-1} from a uniform distribution in [0, 2*pi]\n    theta = theta.at[-1].set(random.uniform(key, shape=(), minval=0, maxval=2 * jnp.pi))\n\n    # Generate theta_j for j = 1, ..., d-2 using bisection method\n    # TODO: vectorize this loop\n    for j in range(0, d - 2, 1):\n        # JAX PRNG is stateless, so we need to split the key\n        key, subkey = random.split(key)\n        x = random.uniform(key, shape=(), minval=0, maxval=1)\n\n        theta_j = get_theta(\n            F=lambda theta: F_j(theta, j, d),\n            a=0,\n            b=jnp.pi,\n            x=x,\n            eps=1e-9,\n        )\n\n        theta = theta.at[j].set(theta_j)\n\n    # e2 has dimension d\n    e2: Array = jnp.ones(d)\n\n    # e2[1] to e2[d-1] have products of sin(theta) terms\n    # TODO: vectorize this loop\n    for j in range(1, d):\n        e2 = e2.at[j].set(e2[j - 1] * jnp.sin(theta[j - 1]))\n\n    theta = jnp.append(theta, 0)  # Append 0 for cos(0) of last coordinate\n\n    # e2[d] has additional cos(theta) term in product\n    e2 = e2 * jnp.cos(theta)\n\n    return theta, e2\n</code></pre>"},{"location":"orthonormal/","title":"<code>orthonormal</code>","text":"<p>This module contains functions to calculate the orthonormal basis representing the hyperplane $\\Pi$ that is tangential to the hypersphere $S_{d-1}$ representing the input state.</p>"},{"location":"orthonormal/#isotropic.orthonormal","title":"<code>isotropic.orthonormal</code>","text":"<p>This module contains functions for constructing orthonormal basis of Pi.</p>"},{"location":"orthonormal/#isotropic.orthonormal.get_orthonormal_basis","title":"<code>get_orthonormal_basis(Phi)</code>","text":"<p>Construct an orthonormal basis given a point $\\Phi$ on a unit sphere.</p> <p>The point $\\Phi$ is given by a d+1 dimensional vector and the orthonormal basis consists of d vectors each of dimension d+1, which are orthogonal to $\\Phi$ and to each other.</p> <p>Parameters:</p> Name Type Description Default <code>Phi</code> <code>ArrayLike</code> <p>A point on the unit sphere, should be a normalized vector.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>An orthonormal basis of dimension (d, d+1).</p> Source code in <code>src/isotropic/orthonormal.py</code> <pre><code>def get_orthonormal_basis(Phi: ArrayLike) -&gt; Array:\n    \"\"\"\n    Construct an orthonormal basis given a point $\\\\Phi$ on a unit sphere.\n\n    The point $\\\\Phi$ is given by a d+1 dimensional vector and the orthonormal basis consists of d vectors\n    each of dimension d+1, which are orthogonal to $\\\\Phi$ and to each other.\n\n    Parameters\n    ----------\n    Phi : ArrayLike\n        A point on the unit sphere, should be a normalized vector.\n\n    Returns\n    -------\n    Array\n        An orthonormal basis of dimension (d, d+1).\n    \"\"\"\n    Phi = jnp.array(Phi)\n    dim = len(Phi)  # d+1\n\n    # Verify Phi is normalized (within numerical precision)\n    norm_phi = jnp.linalg.norm(Phi)\n    Phi = jnp.where(jnp.abs(norm_phi - 1.0) &gt; 1e-10, Phi / norm_phi, Phi)\n\n    if Phi[0] != 0 or Phi[1] != 0:\n        v1 = jnp.array([Phi[1], -Phi[0]])\n    else:\n        v1 = jnp.array([1.0, 0.0])\n\n    v1 = v1 / jnp.linalg.norm(v1)\n    v1 = jnp.pad(v1, (0, dim - 2), mode=\"constant\", constant_values=0)\n\n    basis_vectors = v1.reshape(1, -1)\n\n    for i in range(2, dim):\n        A = jnp.vstack([basis_vectors[:, : i + 1], Phi[: i + 1]])\n        x = jax_null_space(A).squeeze()\n        x = x / jnp.linalg.norm(x)\n        x = jnp.pad(x, (0, dim - len(x)), mode=\"constant\", constant_values=0)\n        basis_vectors = jnp.vstack([basis_vectors, x])\n\n    return basis_vectors\n</code></pre>"},{"location":"thetazero/","title":"<code>thetazero</code>","text":"<p>This module contains functions to calculate the angle $\\theta_0$ with a normal distribution.</p>"},{"location":"thetazero/#isotropic.thetazero","title":"<code>isotropic.thetazero</code>","text":"<p>This module contains functions for generating $\\theta_0$.</p>"},{"location":"thetazero/#isotropic.thetazero.get_theta_zero","title":"<code>get_theta_zero(x, g)</code>","text":"<p>Calculate the inverse angle $\\theta_0$ with a normal distribution given a value x.</p> <p>This function finds the angle $\\theta_0$ such that the integral of g from 0 to $\\theta_0$ equals x. It uses Simpson's rule for numerical integration and a bisection method to find the root.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ArrayLike</code> <p>Value for which to find the inverse, should be uniformly distributed in $[0, 1]$.</p> required <code>g</code> <code>Callable</code> <p>Function $g(\\theta)$ that is integrated to calculate $F(\\theta)$.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Value of $\\theta_0$.</p> Source code in <code>src/isotropic/thetazero.py</code> <pre><code>def get_theta_zero(x: ArrayLike, g: Callable) -&gt; float:\n    \"\"\"\n    Calculate the inverse angle $\\\\theta_0$ with a normal distribution given a value x.\n\n    This function finds the angle $\\\\theta_0$ such that the integral of g from 0 to $\\\\theta_0$ equals x.\n    It uses Simpson's rule for numerical integration and a bisection method to find the root.\n\n    Parameters\n    ----------\n    x : ArrayLike\n        Value for which to find the inverse, should be uniformly distributed in $[0, 1]$.\n    g : Callable\n        Function $g(\\\\theta)$ that is integrated to calculate $F(\\\\theta)$.\n\n    Returns\n    -------\n    float\n        Value of $\\\\theta_0$.\n    \"\"\"\n\n    # We wrap the function g into a callable F that integrates g from 0 to theta.\n    def F(theta: float) -&gt; Array:\n        # TODO: Provide the correct value for C based on the 4th derivative bound\n        return simpsons_rule(g, 0, theta, 1, 1e-15)\n\n    # Use bisection to find theta_0 such that the integral equals x\n    theta_zero: float = get_theta(F, 0, jnp.pi, x, 1e-15)\n\n    return theta_zero\n</code></pre>"},{"location":"utils/","title":"<code>utils</code>","text":"<p>This module contains miscellaneous utilities useful for various steps involved in the isotropic error generation.</p>"},{"location":"utils/#isotropic.utils","title":"<code>isotropic.utils</code>","text":""},{"location":"utils/#isotropic.utils.bisection","title":"<code>bisection</code>","text":"<p>This module contains functions for the bisection algorithm to calculate $F^{-1}$.</p>"},{"location":"utils/#isotropic.utils.bisection.get_theta","title":"<code>get_theta(F, a, b, x, eps)</code>","text":"<p>Find the value of theta such that $F(\\theta) = x$ using the bisection method.</p> <p>Parameters:</p> Name Type Description Default <code>F</code> <code>Callable</code> <p>Function for which to compute the inverse.</p> required <code>a</code> <code>float</code> <p>Lower bound of the interval.</p> required <code>b</code> <code>float</code> <p>Upper bound of the interval.</p> required <code>x</code> <code>float | ArrayLike</code> <p>Value for which to find the inverse.</p> required <code>eps</code> <code>float</code> <p>Tolerance for convergence.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The value of $theta$ such that $F(\\theta) = x$.</p> Notes <p>This function assumes that $F$ is an increasing function in the interval $[a, b]$ and that $F(a) \\leq x \\leq F(b)$. The bisection method is a root-finding method that repeatedly bisects an interval and then selects a subinterval in which a root exists.</p> Source code in <code>src/isotropic/utils/bisection.py</code> <pre><code>def get_theta(\n    F: Callable, a: float, b: float, x: float | ArrayLike, eps: float\n) -&gt; float:\n    \"\"\"\n    Find the value of theta such that $F(\\\\theta) = x$ using the bisection method.\n\n    Parameters\n    ----------\n    F : Callable\n        Function for which to compute the inverse.\n    a : float\n        Lower bound of the interval.\n    b : float\n        Upper bound of the interval.\n    x : float | ArrayLike\n        Value for which to find the inverse.\n    eps : float\n        Tolerance for convergence.\n\n    Returns\n    -------\n    float\n        The value of $theta$ such that $F(\\\\theta) = x$.\n\n    Notes\n    -----\n    This function assumes that $F$ is an increasing function in the interval $[a, b]$\n    and that $F(a) \\\\leq x \\\\leq F(b)$. The bisection method is a root-finding method\n    that repeatedly bisects an interval and then selects a subinterval in which a root exists.\n    \"\"\"\n    while b - a &gt; eps:\n        c = (a + b) / 2.0\n        Fc = F(c)\n        if Fc &lt;= x:\n            a = c\n        else:\n            b = c\n    return (a + b) / 2.0\n</code></pre>"},{"location":"utils/#isotropic.utils.data_generation","title":"<code>data_generation</code>","text":"<p>This module generates data for Grover's algorithm with isotropic error.</p>"},{"location":"utils/#isotropic.utils.data_generation.generate_data","title":"<code>generate_data(num_qubits, min_iterations, max_iterations, min_sigma, max_sigma, num_sigma_points=2, num_jobs=2, data_dir='data')</code>","text":"<p>Generate data for Grover's algorithm with isotropic error and save to xarray files.</p> <p>Parameters:</p> Name Type Description Default <code>num_qubits</code> <code>int</code> <p>Number of qubits in the Grover's algorithm.</p> required <code>min_iterations</code> <code>int</code> <p>Minimum number of Grover iterations to simulate.</p> required <code>max_iterations</code> <code>int</code> <p>Maximum number of Grover iterations to simulate.</p> required <code>min_sigma</code> <code>float</code> <p>Minimum sigma value for isotropic error.</p> required <code>max_sigma</code> <code>float</code> <p>Maximum sigma value for isotropic error.</p> required <code>num_sigma_points</code> <code>int</code> <p>Number of sigma points to evaluate between min_sigma and max_sigma. Default is 2.</p> <code>2</code> <code>num_jobs</code> <code>int</code> <p>Number of parallel jobs to use for computation. Default is 2.</p> <code>2</code> <code>data_dir</code> <code>str</code> <p>Directory to save the generated data files. Default is \"data\".</p> <code>'data'</code> <p>Returns:</p> Type Description <code>None</code> <p>Saves the generated data to xarray files.</p> Source code in <code>src/isotropic/utils/data_generation.py</code> <pre><code>def generate_data(\n    num_qubits: int,\n    min_iterations: int,\n    max_iterations: int,\n    min_sigma: float,\n    max_sigma: float,\n    num_sigma_points: int = 2,\n    num_jobs: int = 2,\n    data_dir: str = \"data\",\n) -&gt; None:\n    \"\"\"\n    Generate data for Grover's algorithm with isotropic error and save to xarray files.\n\n    Parameters\n    ----------\n    num_qubits : int\n        Number of qubits in the Grover's algorithm.\n    min_iterations : int\n        Minimum number of Grover iterations to simulate.\n    max_iterations : int\n        Maximum number of Grover iterations to simulate.\n    min_sigma : float\n        Minimum sigma value for isotropic error.\n    max_sigma : float\n        Maximum sigma value for isotropic error.\n    num_sigma_points : int, optional\n        Number of sigma points to evaluate between min_sigma and max_sigma. Default is 2.\n    num_jobs : int, optional\n        Number of parallel jobs to use for computation. Default is 2.\n    data_dir : str, optional\n        Directory to save the generated data files. Default is \"data\".\n\n    Returns\n    -------\n    None\n        Saves the generated data to xarray files.\n    \"\"\"\n    # We first implement the oracle that will add a phase to our desired search item.\n    # Note the negative sign on one of the diagonal entries.\n    # TODO: change hardcoded grover oracle\n    oracle = jnp.eye(2**num_qubits).tolist()\n    oracle[3][3] = -1\n    U_w = Operator(oracle)\n    marked_item = \"0\" * (num_qubits - 2) + \"11\"\n\n    os.makedirs(data_dir, exist_ok=True)\n    for iterations in range(min_iterations, max_iterations + 1):\n        data = run_experiment(\n            num_qubits=num_qubits,\n            U_w=U_w,\n            iterations=iterations,\n            marked_item=marked_item,\n            min_sigma=min_sigma,\n            max_sigma=max_sigma,\n            num_sigma_points=num_sigma_points,\n            num_jobs=num_jobs,\n        )\n        # Save xarray data to file\n        data.to_netcdf(\n            f\"{data_dir}/grover_{num_qubits}_qubits_{iterations}_iterations.nc\"\n        )\n</code></pre>"},{"location":"utils/#isotropic.utils.data_generation.run_experiment","title":"<code>run_experiment(num_qubits, U_w, iterations, marked_item, min_sigma, max_sigma, num_sigma_points, num_jobs)</code>","text":"<p>Run Grover's algorithm experiment with isotropic error and return results as xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>num_qubits</code> <code>int</code> <p>Number of qubits in the Grover's algorithm.</p> required <code>U_w</code> <code>Operator</code> <p>Oracle operator for Grover's algorithm.</p> required <code>iterations</code> <code>int</code> <p>Number of Grover iterations to perform.</p> required <code>marked_item</code> <code>str</code> <p>The marked item to search for in binary string format.</p> required <code>min_sigma</code> <code>float</code> <p>Minimum sigma value for isotropic error.</p> required <code>max_sigma</code> <code>float</code> <p>Maximum sigma value for isotropic error.</p> required <code>num_sigma_points</code> <code>int</code> <p>Number of sigma points to evaluate between min_sigma and max_sigma.</p> required <code>num_jobs</code> <code>int</code> <p>Number of parallel jobs to use for computation.</p> required <p>Returns:</p> Type Description <code>Dataset</code> <p>Xarray Dataset containing success probabilities for different sigma values.</p> Source code in <code>src/isotropic/utils/data_generation.py</code> <pre><code>def run_experiment(\n    num_qubits: int,\n    U_w: Operator,\n    iterations: int,\n    marked_item: str,\n    min_sigma: float,\n    max_sigma: float,\n    num_sigma_points: int,\n    num_jobs: int,\n) -&gt; xr.Dataset:\n    \"\"\"\n    Run Grover's algorithm experiment with isotropic error and return results as xarray Dataset.\n\n    Parameters\n    ----------\n    num_qubits : int\n        Number of qubits in the Grover's algorithm.\n    U_w : Operator\n        Oracle operator for Grover's algorithm.\n    iterations : int\n        Number of Grover iterations to perform.\n    marked_item : str\n        The marked item to search for in binary string format.\n    min_sigma : float\n        Minimum sigma value for isotropic error.\n    max_sigma : float\n        Maximum sigma value for isotropic error.\n    num_sigma_points : int\n        Number of sigma points to evaluate between min_sigma and max_sigma.\n    num_jobs : int\n        Number of parallel jobs to use for computation.\n\n    Returns\n    -------\n    xr.Dataset\n        Xarray Dataset containing success probabilities for different sigma values.\n    \"\"\"\n    # Grover's Circuit\n    grover_circuit = get_grover_circuit(\n        num_qubits=num_qubits, U_w=U_w, iterations=iterations\n    )\n\n    # error free final statevector before measurements\n    statevector = Statevector(grover_circuit)\n\n    # The probability of measuring the $0011$ state gives us a likelihood of success for our search exercise.\n    error_free_success = statevector.probabilities_dict()[marked_item]\n\n    # Effect of error levels on success probability\n    ## Pre-compute error parameters that are independent of sigma\n    Phi = statevector.data\n    Phi_spherical = statevector_to_hypersphere(Phi)\n    basis = get_orthonormal_basis(\n        Phi_spherical\n    )  # gives d vectors with d+1 elements each\n    key = random.PRNGKey(0)\n    theta, coeffs = get_e2_coeffs(\n        d=basis.shape[0],  # gives d coefficients for the d vectors above\n        F_j=F_j,\n        key=key,\n    )\n    e2 = jnp.expand_dims(coeffs, axis=-1) * basis\n\n    # sigma specific calculations\n    def get_success_after_error(sigma):\n        def g(theta):\n            return normal_integrand(theta, d=Phi_spherical.shape[0], sigma=sigma)\n\n        x = random.uniform(key, shape=(), minval=0, maxval=1)\n        theta_zero = get_theta_zero(x=x, g=g)\n        Psi_spherical = add_isotropic_error(Phi_spherical, e2=e2, theta_zero=theta_zero)\n        Psi = hypersphere_to_statevector(Psi_spherical)\n        statevector_error = Statevector(Psi.tolist())\n        return statevector_error.probabilities_dict()[marked_item]\n\n    sigmas = jnp.linspace(min_sigma, max_sigma, num_sigma_points)\n\n    TIMEOUT = 99999  # see https://stackoverflow.com/a/71977764\n    error_success = Parallel(n_jobs=num_jobs, timeout=TIMEOUT)(\n        delayed(get_success_after_error)(sigma) for sigma in sigmas\n    )\n\n    error_success.append(error_free_success)\n\n    # Create xarray Dataset\n    data = xr.Dataset(\n        {\n            \"success_probability\": ([\"sigma\"], error_success),\n            \"iterations\": iterations,\n        },\n        coords={\n            \"sigma\": jnp.append(sigmas, jnp.array([1.0])),\n        },\n        attrs={\n            \"num_qubits\": num_qubits,\n            \"marked_item\": marked_item,\n        },\n    )\n\n    return data\n</code></pre>"},{"location":"utils/#isotropic.utils.distribution","title":"<code>distribution</code>","text":"<p>This module contains functions for relevant probability distributions.</p>"},{"location":"utils/#isotropic.utils.distribution.double_factorial_jax","title":"<code>double_factorial_jax(n)</code>","text":"<p>Helper function to compute double factorial.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The integer for which to compute the double factorial.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>The value of the double factorial n!! as a JAX array.</p> Notes <p>The double factorial is defined as:</p> <pre><code>n!! = n * (n-2) * (n-4) * ... * 1 (if n is odd) or 2 (if n is even).\n</code></pre> Source code in <code>src/isotropic/utils/distribution.py</code> <pre><code>def double_factorial_jax(n: int) -&gt; Array:\n    \"\"\"\n    Helper function to compute double factorial.\n\n    Parameters\n    ----------\n    n : int\n        The integer for which to compute the double factorial.\n\n    Returns\n    -------\n    Array\n        The value of the double factorial n!! as a JAX array.\n\n    Notes\n    -----\n    The double factorial is defined as:\n\n        n!! = n * (n-2) * (n-4) * ... * 1 (if n is odd) or 2 (if n is even).\n    \"\"\"\n    # works for numbers as large as 9**6\n    return jnp.where(n &lt;= 0, 1, jnp.prod(jnp.arange(n, 0, -2, dtype=jnp.uint64)))\n</code></pre>"},{"location":"utils/#isotropic.utils.distribution.double_factorial_ratio","title":"<code>double_factorial_ratio(num, den)</code>","text":"<p>Compute the ratio of double factorials num!! / den!! .</p> <p>Parameters:</p> Name Type Description Default <code>num</code> <code>int</code> <p>The numerator double factorial.</p> required <code>den</code> <code>int</code> <p>The denominator double factorial.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The ratio num!! / den!! .</p> Source code in <code>src/isotropic/utils/distribution.py</code> <pre><code>def double_factorial_ratio(num: int, den: int) -&gt; float:\n    \"\"\"\n    Compute the ratio of double factorials num!! / den!! .\n\n    Parameters\n    ----------\n    num : int\n        The numerator double factorial.\n    den : int\n        The denominator double factorial.\n\n    Returns\n    -------\n    float\n        The ratio num!! / den!! .\n    \"\"\"\n    num_list = list(range(num, 0, -2))\n    den_list = list(range(den, 0, -2))\n    # make sure both lists are the same length by padding the shorter one with 1s\n    max_len = max(len(num_list), len(den_list))\n    num_list += [1] * (max_len - len(num_list))\n    den_list += [1] * (max_len - len(den_list))\n    num_array = np.array(num_list)\n    den_array = np.array(den_list)\n\n    def ratio(a, b):\n        return a / b\n\n    result_array = np.vectorize(ratio)(num_array, den_array)\n    return np.prod(result_array)\n</code></pre>"},{"location":"utils/#isotropic.utils.distribution.normal_integrand","title":"<code>normal_integrand(theta, d, sigma)</code>","text":"<p>Compute the function g(\u03b8).</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>float</code> <p>Angle parameter(s).</p> required <code>d</code> <code>int</code> <p>Dimension parameter.</p> required <code>sigma</code> <code>float</code> <p>Sigma parameter (should be in valid range).</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Value(s) of the function evaluated at <code>theta</code>.</p> Notes <p>g(\u03b8) is integrated to calculate F(\u03b8) which is the distribution function for the angle \u03b8 in a normal distribution:</p> <p>$$g(\\theta) = \\frac{(d-1)!! \\times (1-\\sigma^2) \\times \\sin^{d-1}(\\theta)}{\\pi \\times (d-2)!! \\times (1+\\sigma^2-2\\sigma\\cos(\\theta))^{(d+1)/2}}$$.</p> Source code in <code>src/isotropic/utils/distribution.py</code> <pre><code>def normal_integrand(theta: float, d: int, sigma: float) -&gt; Array:\n    \"\"\"\n    Compute the function g(\u03b8).\n\n    Parameters\n    ----------\n    theta : float\n        Angle parameter(s).\n    d : int\n        Dimension parameter.\n    sigma : float\n        Sigma parameter (should be in valid range).\n\n    Returns\n    -------\n    Array\n        Value(s) of the function evaluated at `theta`.\n\n    Notes\n    -----\n    g(\u03b8) is integrated to calculate F(\u03b8) which is the\n    distribution function for the angle \u03b8 in a normal distribution:\n\n    $$g(\\\\theta) = \\\\frac{(d-1)!! \\\\times (1-\\\\sigma^2) \\\\times \\\\sin^{d-1}(\\\\theta)}{\\\\pi \\\\times (d-2)!! \\\\times (1+\\\\sigma^2-2\\\\sigma\\\\cos(\\\\theta))^{(d+1)/2}}$$.\n    \"\"\"\n\n    # factorial ratio\n    factorial_ratio = double_factorial_ratio(d - 1, d - 2)\n\n    # Numerator components\n    one_minus_sigma_sq = 1.0 - sigma**2\n    sin_theta_power = jnp.power(jnp.sin(theta), d - 1)\n\n    # Denominator components\n    denominator_base = 1.0 + sigma**2 - 2.0 * sigma * jnp.cos(theta)\n    denominator_power = jnp.power(denominator_base, (d + 1) / 2.0)\n\n    # Combine all terms\n    result = (\n        factorial_ratio\n        * (one_minus_sigma_sq * sin_theta_power)\n        / (jnp.pi * denominator_power)\n    )\n\n    return result\n</code></pre>"},{"location":"utils/#isotropic.utils.linalg","title":"<code>linalg</code>","text":""},{"location":"utils/#isotropic.utils.linalg.jax_null_space","title":"<code>jax_null_space(A)</code>","text":"<p>Compute the null space of a matrix $A$ using JAX.</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>ArrayLike</code> <p>The input matrix for which to compute the null space.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>The basis vectors of the null space of A.</p> Notes <p>See also:</p> <ul> <li><code>scipy.linalg.null_space</code> for the reference implementation in SciPy.</li> <li>https://github.com/jax-ml/jax/pull/14486 for an old JAX implementation.</li> </ul> Source code in <code>src/isotropic/utils/linalg.py</code> <pre><code>def jax_null_space(A: ArrayLike) -&gt; Array:\n    \"\"\"\n    Compute the null space of a matrix $A$ using JAX.\n\n    Parameters\n    ----------\n    A : ArrayLike\n        The input matrix for which to compute the null space.\n\n    Returns\n    -------\n    Array\n        The basis vectors of the null space of A.\n\n    Notes\n    -----\n    See also:\n\n    - `scipy.linalg.null_space` for the reference implementation in SciPy.\n    - [https://github.com/jax-ml/jax/pull/14486](https://github.com/jax-ml/jax/pull/14486) for an old JAX implementation.\n    \"\"\"\n    u, s, vh = svd(A, full_matrices=True)\n    M, N = u.shape[0], vh.shape[1]\n    rcond = jnp.finfo(s.dtype).eps * max(M, N)\n    tol = jnp.amax(s, initial=0.0) * rcond\n    num = jnp.sum(s &gt; tol, dtype=int)\n    Q = vh[num:, :].T.conj()\n    return Q\n</code></pre>"},{"location":"utils/#isotropic.utils.simpsons","title":"<code>simpsons</code>","text":"<p>This module contains functions for estimating the integral of a function using Simpson's rule.</p>"},{"location":"utils/#isotropic.utils.simpsons.simpsons_rule","title":"<code>simpsons_rule(f, a, b, C, tol)</code>","text":"<p>Estimate the integral of a function using Simpson's rule.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable</code> <p>Function to integrate.</p> required <code>a</code> <code>float</code> <p>Lower limit of integration.</p> required <code>b</code> <code>float</code> <p>Upper limit of integration.</p> required <code>C</code> <code>float</code> <p>Bound on 4th derivative of f.</p> required <code>tol</code> <code>float</code> <p>Desired tolerance for the integral estimate.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Estimated value of the integral.</p> Source code in <code>src/isotropic/utils/simpsons.py</code> <pre><code>def simpsons_rule(f: Callable, a: float, b: float, C: float, tol: float) -&gt; Array:\n    \"\"\"\n    Estimate the integral of a function using Simpson's rule.\n\n    Parameters\n    ----------\n    f : Callable\n        Function to integrate.\n    a : float\n        Lower limit of integration.\n    b : float\n        Upper limit of integration.\n    C : float\n        Bound on 4th derivative of f.\n    tol : float\n        Desired tolerance for the integral estimate.\n\n    Returns\n    -------\n    Array\n        Estimated value of the integral.\n    \"\"\"\n    # Estimate minimum number of intervals needed for given tolerance\n    n: int = int(jnp.ceil(((180 * tol) / (C * (b - a) ** 5)) ** (-0.25)))\n    if n % 2 == 1:\n        n += 1  # Simpson's rule requires even n\n\n    x: Array = jnp.linspace(a, b, n + 1)\n    y: Array = f(x)\n\n    S: Array = y[0] + y[-1] + 4 * jnp.sum(y[1:-1:2]) + 2 * jnp.sum(y[2:-2:2])\n    integral: Array = (b - a) / (3 * n) * S\n    return integral\n</code></pre>"},{"location":"utils/#isotropic.utils.state_transforms","title":"<code>state_transforms</code>","text":"<p>This module contains functions for transforming the quantum state.</p>"},{"location":"utils/#isotropic.utils.state_transforms.add_isotropic_error","title":"<code>add_isotropic_error(Phi_sp, e2, theta_zero)</code>","text":"<p>Add isotropic error to state $\\Phi$ given $e_2$ and $\\theta_0$.</p> <p>Parameters:</p> Name Type Description Default <code>Phi_sp</code> <code>ArrayLike</code> <p>State to which isotropic error is added (in spherical form).</p> required <code>e2</code> <code>ArrayLike</code> <p>Vector $e_2$ in $S_{d-1}$ with uniform distribution.</p> required <code>theta_zero</code> <code>float</code> <p>Angle $\\theta_0$ in $[0,\\pi]$ with density function $f(\\theta_0)$.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Statevector in spherical form after adding isotropic error.</p> Source code in <code>src/isotropic/utils/state_transforms.py</code> <pre><code>def add_isotropic_error(Phi_sp: Array, e2: Array, theta_zero: float) -&gt; Array:\n    \"\"\"\n    Add isotropic error to state $\\\\Phi$ given $e_2$ and $\\\\theta_0$.\n\n    Parameters\n    ----------\n    Phi_sp : ArrayLike\n        State to which isotropic error is added (in spherical form).\n    e2 : ArrayLike\n        Vector $e_2$ in $S_{d-1}$ with uniform distribution.\n    theta_zero : float\n        Angle $\\\\theta_0$ in $[0,\\\\pi]$ with density function $f(\\\\theta_0)$.\n\n    Returns\n    -------\n    Array\n        Statevector in spherical form after adding isotropic error.\n    \"\"\"\n    Psi_sp = (Phi_sp * jnp.cos(theta_zero)) + (\n        (jnp.sum(e2, axis=0)) * jnp.sin(theta_zero)\n    )\n    return Psi_sp\n</code></pre>"},{"location":"utils/#isotropic.utils.state_transforms.generate_and_add_isotropic_error","title":"<code>generate_and_add_isotropic_error(Phi, sigma=0.9, key=random.PRNGKey(0))</code>","text":"<p>Generate and add isotropic error to a given statevector.</p> <p>Parameters:</p> Name Type Description Default <code>Phi</code> <code>ArrayLike</code> <p>The input statevector as a complex JAX array of dimension $2^n$, for n-qubits.</p> required <code>sigma</code> <code>float</code> <p>The standard deviation for the isotropic error, by default 0.9.</p> <code>0.9</code> <code>key</code> <code>ArrayLike</code> <p>Random key for reproducibility, by default random.PRNGKey(0).</p> <code>PRNGKey(0)</code> <p>Returns:</p> Type Description <code>Array</code> <p>The perturbed statevector after adding isotropic error.</p> Source code in <code>src/isotropic/utils/state_transforms.py</code> <pre><code>def generate_and_add_isotropic_error(\n    Phi: ArrayLike,\n    sigma: float = 0.9,\n    key: ArrayLike = random.PRNGKey(0),\n) -&gt; Array:\n    \"\"\"\n    Generate and add isotropic error to a given statevector.\n\n    Parameters\n    ----------\n    Phi : ArrayLike\n        The input statevector as a complex JAX array of dimension $2^n$, for n-qubits.\n    sigma : float, optional\n        The standard deviation for the isotropic error, by default 0.9.\n    key : ArrayLike, optional\n        Random key for reproducibility, by default random.PRNGKey(0).\n\n    Returns\n    -------\n    Array\n        The perturbed statevector after adding isotropic error.\n    \"\"\"\n    # Set up logging\n\n    Phi_spherical = statevector_to_hypersphere(Phi)\n    basis = get_orthonormal_basis(\n        Phi_spherical\n    )  # gives d vectors with d+1 elements each\n    theta, coeffs = get_e2_coeffs(\n        d=basis.shape[0],  # gives d coefficients for the d vectors above\n        F_j=F_j,\n        key=key,\n    )\n    e2 = jnp.expand_dims(coeffs, axis=-1) * basis\n\n    def g(theta):\n        return normal_integrand(theta, d=Phi_spherical.shape[0], sigma=sigma)\n\n    x = random.uniform(key, shape=(), minval=0, maxval=1)\n    theta_zero = get_theta_zero(x=x, g=g)\n    Psi_spherical = add_isotropic_error(Phi_spherical, e2=e2, theta_zero=theta_zero)\n    Psi = hypersphere_to_statevector(Psi_spherical)\n    return Psi\n</code></pre>"},{"location":"utils/#isotropic.utils.state_transforms.hypersphere_to_statevector","title":"<code>hypersphere_to_statevector(S)</code>","text":"<p>Generate the statevector $\\Phi$ from hypersphere $S$.</p> <p>Parameters:</p> Name Type Description Default <code>S</code> <code>ArrayLike</code> <p>Hypersphere as a real JAX array of dimension $2^{n+1}$ for n qubits.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Statevector as a complex JAX array of dimension $2^n$.</p> Source code in <code>src/isotropic/utils/state_transforms.py</code> <pre><code>def hypersphere_to_statevector(S: Array) -&gt; Array:\n    \"\"\"\n    Generate the statevector $\\\\Phi$ from hypersphere $S$.\n\n    Parameters\n    ----------\n    S : ArrayLike\n        Hypersphere as a real JAX array of dimension $2^{n+1}$ for n qubits.\n\n    Returns\n    -------\n    Array\n        Statevector as a complex JAX array of dimension $2^n$.\n    \"\"\"\n    Phi = jnp.zeros(int(2 ** (log(S.shape[0], 2) - 1)), dtype=complex)\n    for x in range(Phi.shape[0]):\n        Phi = Phi.at[x].set(S[2 * x] + 1j * S[2 * x + 1])\n    return Phi\n</code></pre>"},{"location":"utils/#isotropic.utils.state_transforms.statevector_to_hypersphere","title":"<code>statevector_to_hypersphere(Phi)</code>","text":"<p>Generate the hypersphere from statevector $\\Phi$.</p> <p>Parameters:</p> Name Type Description Default <code>Phi</code> <code>ArrayLike</code> <p>Statevector as a complex JAX array of dimension $2^n$, for n-qubits.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Hypersphere as a real JAX array of dimension $2^{n+1}$.</p> Source code in <code>src/isotropic/utils/state_transforms.py</code> <pre><code>def statevector_to_hypersphere(Phi: Array) -&gt; Array:\n    \"\"\"\n    Generate the hypersphere from statevector $\\\\Phi$.\n\n    Parameters\n    ----------\n    Phi : ArrayLike\n        Statevector as a complex JAX array of dimension $2^n$, for n-qubits.\n\n    Returns\n    -------\n    Array\n        Hypersphere as a real JAX array of dimension $2^{n+1}$.\n    \"\"\"\n    S = jnp.zeros(int(2 ** (log(Phi.shape[0], 2) + 1)), dtype=float)\n    for x in range(S.shape[0] // 2):\n        S = S.at[2 * x].set(Phi[x].real)\n        S = S.at[2 * x + 1].set(Phi[x].imag)\n    return S\n</code></pre>"}]}